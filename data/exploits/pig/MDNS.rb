require 'pp'
require 'msf/core'
require 'net/dns/packet'

class MDNSParser
    attr_reader :questions, :answers, :additional, :authoritative, :headers

	def initialize(data)
		@data = data
		@rrtypes = []
		@classes = []
		@idx = 0
		@headers = {}

		pop_rrtypes
		pop_classes
		id, flag, qc , ac , auc, adc= data.unpack('nnnnnn')
		@headers[:id] = id
		@headers[:question_count] = qc
		@headers[:answer_count] = ac
		@headers[:authority_count] = auc
		@headers[:additional_count] = adc
		@headers[:answer] = 1 if (flag >> 15 ) & 1
		@headers[:question] = 1 if (flag >> 11 ) & 1
		@headers[:authoritive] = 1 if (flag >> 10 ) & 1
		@headers[:truncated] = 1 if (flag >> 9 ) & 1
		@headers[:recursion_desired] = 1 if (flag >> 8 ) & 1
		@headers[:recursion_avail] = 1 if (flag >> 7 ) & 1
		@headers[:error] = 1 if flag & 1
		@questions = []
		@answers = []
		@additional = []
		@authoritative = []
		@idx = 12

		(1..qc).each { |i|
			q = get_question()
			@questions << q
		}
		(1..ac).each { |i|
			a = get_answer()
			@answers<< a
            break if a[:rrtype] == "NULL" or a[:rrtype] == ""
		}
		(1..auc).each { |i|
			a = get_answer()
			@authoritative << a
            break if a[:rrtype] == "NULL" or a[:rrtype] == ""
		}
		(1..adc).each { |i|
			a = get_answer()
			@additional << a
            break if a[:rrtype] == "NULL" or a[:rrtype] == ""
		}
        @data = @data[@idx..-1]
        @rrtypes = nil
        @classes = nil

	end

	def pop_classes
		@classes[1] = "IN"
		@classes[3] = "CH"
		@classes[4] = "HS"
		@classes[255] = "ANY"
		
	end
	def pop_rrtypes
		@rrtypes = ['N/A','A', 'NS', 'MD', 'MF', 'CNAME', 'SOA', 'MB', 'MG', 'MR', 'NULL', 'WKS', 'PTR', 'HINFO', 'MINFO', 'MX', 'TXT', 'RP', 'AFSDB', 'X25', 'ISDN', 'RT', 'NSAP', 'NSAP-PTR', 'SIG', 'KEY', 'PX', 'GPOS', 'AAAA', 'LOC', 'NXT', 'EID', 'NIMLOC', 'SRV', 'ATMA', 'NAPTR', 'KX', 'CERT', 'A6', 'DNAME', 'SINK', 'OPT', 'APL', 'DS', 'SSHFP', 'IPSECKEY', 'RRSIG', 'NSEC', 'DNSKEY', 'DHCID', 'NSEC3', 'NSEC3PARAM']
		@rrtypes[55] = 'HIP'
		@rrtypes[56] = 'NINFO'
		@rrtypes[57] = 'RKEY'
		@rrtypes[58] = 'TALINK'
		@rrtypes[99] = 'SPF'
		@rrtypes[100] = 'UINFO'
		@rrtypes[101] = 'UID'
		@rrtypes[102] = 'GID'
		@rrtypes[249] = 'TKEY'
		@rrtypes[250] = 'TSIG'
		@rrtypes[251] = 'IXFR'
		@rrtypes[252] = 'AXFR'
		@rrtypes[253] = 'MAILB'
		@rrtypes[254] = 'MAILA'
		@rrtypes[255] = 'ANY'
		
	end
	def get_name
        names = []
        while 1
		    case @data[@idx]
			    when 0
				    @idx += 1
				    return names 
			    when 192..255
				    ti = @idx
				    @idx  = @data[@idx,2].unpack('n')[0] & 0x3fff
				    name = get_name
				    @idx = ti + 2
				    names = names +  name
                    return names
			    else
				    len = @data[@idx]
				    name = @data[@idx+1,len]
				    @idx = @idx + len + 1
				    names << name	
            end
		end
	end

	def get_question
		name = get_name.join(".")
		rrtype,qclass = @data[@idx,4].unpack('nn')
		q = {}
        q[:label] = name
		q[:rrtype] = @rrtypes[rrtype]
		q[:class]  = @classes[qclass & 0x7FFF]
		q[:unicast] = 1 if qclass & 0x8000 == 1
		@idx += 4
		q	
	end
	def get_answer
		name = get_name
		rrtype,qclass, ttl = @data[@idx,8].unpack('nnN')
		a = {}
        a[:label] = name.join('.')
		a[:rrtype] = @rrtypes[rrtype]
		a[:class] = @classes[qclass & 0x7FFF]
		a[:unicast] = 1 if qclass & 0x8000 == 1
		@idx += 8
        case a[:rrtype]
            when 'PTR'
                len = @data[@idx,2].unpack('n').first
                @idx = @idx + 2
                a[:domain_name] = get_name.join(".")
            when 'A'
                len = @data[@idx,2].unpack('n').first
                @idx = @idx + 2
                addr = []
                (@idx..@idx+len-1).to_a.each { |i| 
                    addr << @data[i].to_s }
                @idx = @idx + len
                a[:address] = addr.join('.')
            when 'SRV'
                len,a[:priority],a[:weight],a[:port]  = @data[@idx,8].unpack('nnnn')
                @idx = @idx + 8
                a[:target] = get_name.join('.')
            when 'AAAA'
                len = @data[@idx,2].unpack('n').first
                a[:address] = @data[@idx+2,len].unpack('H*')
                @idx = @idx + len + 2
            when 'TXT'
                len = @data[@idx,2].unpack('n').first
                @idx = @idx + 2
                a[:txt] = []
                endpos = @idx + len
                while @idx < endpos
                    l = @data[@idx]
                    a[:txt] << @data[@idx+1,l]
                    @idx = @idx + l + 1
                end
            when 'NSEC'
                len = @data[@idx,2].unpack('n').first
                @idx = @idx + len + 2 
            else
                print "UNHANDLED TYPE #{a[:rrtype]}\n"
                

        end

		a	
	end

end
class PigMDNS < PigParser

	def register_rules
		self.rules = {
			:ip => { :dst_ip => "224.0.0.251" } , 
			:udp => { :dst_port => 5353  },
		}
	end

    def format_AAAA(a6)
        fstr = []
        i = 0
        a6.to_a.each do |n|
            fstr << n
            fstr << ":" if i > 0 && i % 4 == 0
            i = i + 1
            
        end
        return fstr.to_s.gsub(":0000:","::")
    end
	def parse(pkt)
		eth = pkt[:eth]
		ip = pkt[:ip]
		
		return if not ip or not eth
						
		udp = Racket::L4::UDP.new(ip.payload)
		return if not udp

		return if not udp.payload
		dns = MDNSParser.new(udp.payload)
        print_status("MDNS Packet from: #{ip.src_ip}")
        dns.answers.each do |a|
            next if a[:class] != "IN"
            case a[:rrtype]
                when 'A'
                    name = a[:label].split(".").first
                    report_host(:host => a[:address], :name => name)
                when 'AAAA'
                    name = a[:label]
                when 'SRV'
                    name = a[:target].split(".").first
                    host = @framework.db.workspace.hosts.find_by_name(name)
                    next if host == nil
                    s = a[:label].split(".")
                    p = s.index("_tcp") || s.index("_udp")
                    next if p == nil
                    proto = s[p].gsub("_","")
                    name = s[p-1].gsub("_","")
                    report_service(:host => host[:address], :proto => proto, :port => a[:port], :name => name, :info => s.first)
                when 'TXT'
                    next if a[:txt].length == 0 || a[:txt].first == ""
                    l = a[:label].split('.')
                    next if l.last != "local"

                    le = l.index('local')
                    if l[le -1] == '_tcp' || l[le-1] == '_udp'
                        proto = l[le-1].gsub('_','')
                        portname = l[le-2].gsub('_','')
                        name = l.first
                        noteparent = nil
                        case portname
                            when 'device-info'
                                noteparent = @framework.db.workspace.hosts.find_by_name(name)
                            when 'home-sharing'
                                noteparent = @framework.db.workspace.services.find_by_info(name)
                            else
                                noteparent = @framework.db.workspace.services.find_by_name_and_info(portname,name)
                        end

                        next if noteparent == nil

                        host = noteparent[:address]
                        host = noteparent.host[:address] if noteparent[:host_id]
                       
                        next if host == nil

                        port = noteparent[:port]
                        proto = noteparent[:proto]
                        data = {}
                        a[:txt].each do |n|
                           k,v = n.split("=",2)
                           data[k] = v 
                        end

                        report_note(:host => host, :port => port, :proto => proto, :data => data , :type => 'MDNS.TXT')
                end
                    
          end          
        end

								
	end # end of parse
end

